## 1) 非直接耦合（No/Indirect Coupling）—最佳

**定义**：两个模块互不依赖，或仅通过**事件/消息总线**间接交互。  
**示例**

`# A 只发布事件，不知道谁在订阅 bus.publish("user.created", payload)`

**改进**：保持解耦；若需交互，优先用接口/消息，而非直接调用内部细节。

---

## 2) 数据耦合（Data Coupling）

**定义**：通过**参数传递简单数据**（基本类型/小型 DTO）。  
**示例**

`def resize(img, w: int, h: int): ...`

**改进**：很好；保持参数语义明确、最小必要，不传无关数据。

---

## 3) 标记耦合（Stamp/Structured Coupling，标记/印章）

**定义**：传递**整个结构体/对象**，对方只用到其中一小部分。  
**示例**

`def get_orders(user: User):  # 其实只用 user.id     ...`

**风险**：扩大了不必要的依赖面。  
**改进**：改为传**所需字段**（如 `user_id: int`），或拆小 DTO。

---

## 4) 控制耦合（Control Coupling）

**定义**：通过**控制参数**（如 `mode`、`flag`）影响被调模块的分支走向。  
**示例**

`def export(report, format="csv"):   # 内部 if format == "pdf" ...     ...`

**风险**：调用方在“控制”被调方内部流程。  
**改进**：拆分为多个明确操作（`export_csv`/`export_pdf`），或用策略模式。

---

## 5) 外部耦合（External Coupling）

**定义**：多个模块共同依赖某个**外部约定**（通信协议/文件格式/硬件寄存器布局等）。  
**示例**

`# 多个服务都假设同一个 JSON schema & Topic 名 produce(topic="billing.v1", body=order_json)  # schema 变化会牵连众多模块`

**改进**：引入**防腐层/适配器**，集中管理与外部系统/协议的变化。

---

## 6) 公共耦合（Common Coupling）

**定义**：通过**全局数据**（全局变量、单例可变状态）共享信息。  
**示例**

`CONFIG = {}  # 被各处读写`

**风险**：隐式依赖、难以测试、竞态条件。  
**改进**：依赖注入（将 config 显式作为参数/构造注入），限制可变共享状态。

---

## 7) 内容耦合（Content Coupling）—最差

**定义**：一个模块**直接依赖/修改另一个模块的内部**（跨边界访问私有数据、跳转到内部代码、共享内存结构等）。  
**示例**

`# 直接改别的对象的“内部私有结构” order._items.append(fake_item)   # 破坏封装`

**风险**：高度脆弱，任何内部变化都会“雪崩”。  
**改进**：彻底**封装**内部；仅通过公开接口交互；消除对内部结构的直接访问。

## 速查对照（一句话记忆）

- **内聚（越高越好）**：偶然 < 逻辑 < 时间 < 过程 < 通信 < 顺序 < 功能
    
- **耦合（越低越好）**：非直接 < 数据 < 标记 < 控制 < 外部 < 公共 < 内容