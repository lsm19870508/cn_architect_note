## **1NF（第一范式）——字段不可再分**

**要求**：表中的每个字段必须是**原子值**，不能再分。  
**反例**：

`学生表(Student) 
`学号 | 姓名   | 联系方式 
`1001 | 张三   | 13800000000, 010-88886666`

- 联系方式字段里放了“手机号+座机号”，是一个**可分值**。
    

**改进（1NF）**：

`学生表(Student) 
`学号 | 姓名 | 手机号       | 座机号 
`1001 | 张三 | 13800000000 | 010-88886666`

➡️ 每列都是最小单位，不可再分。

---

## **2NF（第二范式）——消除非主属性对主码的部分依赖**

**要求**：必须先满足 1NF，且**表中每个非主属性都要完全依赖于主码**。  
**反例**：假设“学号+课程号”是主键：

`选课表(Enrollment) 
`学号 | 课程号 | 姓名 | 课程名 | 成绩 
`1001 | C01   | 张三 | 数据库 | 85`

- 主键是 (学号, 课程号)。
    
- “姓名”只依赖学号，不依赖课程号；“课程名”只依赖课程号，不依赖学号。  
    ➡️ 出现**部分依赖**。
    

**改进（2NF）**：  
拆分表：

`学生表(Student) 
`学号 | 姓名  

`课程表(Course) 
`课程号 | 课程名  

`选课表(Enrollment) 
`学号 | 课程号 | 成绩`

➡️ 消除了部分依赖，每个非主属性完全依赖主码。

---

## **3NF（第三范式）——消除传递依赖**

**要求**：必须满足 2NF，且**非主属性之间不能有传递依赖**。  
**反例**：

`学生表(Student) 
`学号 | 姓名 | 系编号 | 系名称 
`1001 | 张三 | D01   | 计算机系`

- 主键是学号。
    
- “系名称”依赖于“系编号”，而“系编号”依赖于主键学号。  
    ➡️ 出现**传递依赖**。
    

**改进（3NF）**：

`学生表(Student) 
`学号 | 姓名 | 系编号  

`系表(Department) 
`系编号 | 系名称`

➡️ 系名称通过系编号独立维护，避免冗余。

---

## **BCNF（Boyce-Codd范式）——每个决定因素都是候选键**

**要求**：比 3NF 更严格，要求**表中每个决定属性的函数依赖，决定因素必须是候选码**。  
**反例**：

`课程教师表(CourseTeacher) 
`课程号 | 教师 | 教师办公电话`

假设约束是：

- 一个课程只能由一个教师讲（课程号 → 教师）。
    
- 一个教师只能讲一门课（教师 → 课程号）。
    
- 教师决定了“办公电话”（教师 → 电话）。
    

那么候选码可以是“课程号”或“教师”。  
但是表中存在 (课程号 → 教师) 和 (教师 → 课程号)，这会造成**BCNF 冲突**。

**改进（BCNF）**：  
拆成两个表：

`课程表(Course) 
`课程号 | 教师  

`教师表(Teacher) 
`教师 | 办公电话`

➡️ 消除了非候选码决定关系，符合 BCNF。

---

## **范式强度对比（从低到高）**

- **1NF**：字段不可分
    
- **2NF**：消除部分依赖
    
- **3NF**：消除传递依赖
    
- **BCNF**：消除所有非候选码决定关系（比 3NF 更严格）
    

> 简单说：**1NF 解决“字段可分” → 2NF 解决“部分依赖” → 3NF 解决“传递依赖” → BCNF 更严格，要求“所有依赖必须由候选码决定”。**