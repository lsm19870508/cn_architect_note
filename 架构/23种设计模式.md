# 创建型（5 个）

## 1) Singleton（单例）

**意图**：系统中**仅一个**实例，并提供全局访问点。  
**何时用**：唯一资源（配置中心、日志器、连接池）。  
**特征**：控制构造、延迟实例化、线程安全。

~~~c++
class Logger {
public:
  static Logger& instance() { static Logger ins; return ins; }
  void log(const std::string& m) {/*...*/}
private: Logger()=default; Logger(const Logger&)=delete; void operator=(const Logger&)=delete;
};
~~~

**优点**：唯一性、懒加载。**缺点**：全局状态耦合、测试困难。  
**辨析**：别滥用；必要时用**依赖注入**替代。

---

## 2) Factory Method（工厂方法）

**意图**：让子类决定创建哪种产品。  
**何时用**：父类知道“要创建产品”，但不知道具体“哪一种”。  
**特征**：抽象工厂方法，延迟到子类实现。

~~~c++
struct Button { virtual void draw()=0; virtual ~Button()=default; };
struct WinButton : Button { void draw() override {/*...*/} };
struct MacButton : Button { void draw() override {/*...*/} };

struct Dialog {
  virtual Button* createButton()=0;
  void render(){ Button* b=createButton(); b->draw(); delete b; }
};
struct WinDialog: Dialog{ Button* createButton() override { return new WinButton; } };
~~~

**优点**：解耦创建与使用。**缺点**：类层级增加。  
**对比**：比**简单工厂**更灵活，但更复杂。

---

## 3) Abstract Factory（抽象工厂）

**意图**：成组产品族的创建，保证同一“主题/风格”。  
**何时用**：跨平台 UI、不同数据库驱动等**相互兼容的一组对象**。  
**特征**：一组工厂方法，产出一组相关产品。

~~~c++
struct Button{virtual void draw()=0;}; struct Checkbox{virtual void toggle()=0;};
struct GUIFactory{ virtual Button* createButton()=0; virtual Checkbox* createCheckbox()=0; };

struct WinFactory: GUIFactory{
  Button* createButton() override {/*...*/}; Checkbox* createCheckbox() override {/*...*/};
};
struct MacFactory: GUIFactory{/*...*/};
~~~

**优点**：产品族一致性。**缺点**：新增产品等级结构困难。  
**对比**：比**工厂方法**更强调“多产品族一致性”。

---

## 4) Builder（建造者）

**意图**：分步骤构建复杂对象，**同样步骤**可生成**不同表示**。  
**何时用**：对象构造步骤复杂/多可选参数（如构建器模式 Fluent API）。  
**特征**：分离“构造过程”和“表示”。

~~~c++
struct HttpRequest {
  std::string method,url; std::vector<std::pair<std::string,std::string>> headers; std::string body;
  struct Builder {
    HttpRequest r;
    Builder& GET(std::string u){ r.method="GET"; r.url=std::move(u); return *this; }
    Builder& header(std::string k,std::string v){ r.headers.emplace_back(k,v); return *this; }
    HttpRequest build(){ return std::move(r); }
  };
};
~~~

**优点**：可读性、可复用。**缺点**：类数增多。  
**对比**：与**抽象工厂**都“创建复杂对象”，但 Builder 强调**过程**与**可配置**。

---

## 5) Prototype（原型）

**意图**：通过**克隆**现有对象生成新对象。  
**何时用**：拷贝成本低于重新构造，或需要运行时决定新对象类型。  
**特征**：clone 接口，深/浅拷贝注意资源所有权。

~~~c++
struct Shape{ virtual Shape* clone() const = 0; virtual ~Shape()=default; };
struct Circle: Shape{ int r; Circle(int r):r(r){} Shape* clone() const override { return new Circle(*this); } };
~~~

**优点**：运行时扩展种类。
**缺点**：深拷贝复杂。

---

# 结构型（7 个）

## 6) Adapter（适配器）

**意图**：将一个接口**转换**成客户期望的另一个接口。  
**何时用**：旧接口与新接口不兼容。  
**特征**：对象适配（组合）更安全，类适配（多继承）更强。

~~~c++
struct Target{ virtual void request()=0; };
struct Adaptee{ void specificRequest(){/*...*/} };
struct Adapter: Target{ Adaptee a; void request() override { a.specificRequest(); } };
~~~

**优点**：复用旧代码。**缺点**：增加层次。  
**对比**：与**Facade**都“包一层”，但 Adapter 为**单对象接口转换**，Facade 为**简化子系统**。

---

## 7) Bridge（桥接）

**意图**：**抽象**与**实现**分离，让它们可独立变化。  
**何时用**：多维度变化（形状×渲染器、消息×发送渠道）。  
**特征**：抽象持有实现接口指针。

~~~c++
struct Renderer{ virtual void drawCircle(int x,int y,int r)=0; };
struct OpenGLRenderer: Renderer{/*...*/}; struct VulkanRenderer: Renderer{/*...*/};

struct Shape{ Renderer* r; Shape(Renderer* r):r(r){} virtual void draw()=0; };
struct Circle: Shape{ int x,y,rad; using Shape::Shape; void draw() override { r->drawCircle(x,y,rad); } };
~~~

**优点**：维度解耦。**缺点**：结构复杂度上升。  
**对比**：与**Strategy**相似，但 Bridge 多用于**结构解耦**而非行为选择。

---

## 8) Composite（组合）

**意图**：将对象组合成树形结构，使“**使用单个对象与组合对象**”一致。  
**何时用**：层级结构（文件系统、UI 组件树）。  
**特征**：Component 接口 + Leaf + Composite。

~~~c++
struct Node{ virtual int size()=0; virtual void add(Node*){} virtual ~Node()=default; };
struct File: Node{ int s; File(int s):s(s){} int size() override { return s; } };
struct Dir: Node{ std::vector<Node*> children; void add(Node* n) override { children.push_back(n); }
  int size() override { int sum=0; for(auto*n:children) sum+=n->size(); return sum; }
};
~~~

**优点**：一致性操作。**缺点**：叶/枝公共接口可能“过宽”。

---

## 9) Decorator（装饰）

**意图**：在**不改变类**的前提下，**动态地**给对象添加职责。  
**何时用**：灵活叠加功能（I/O 流、加密/压缩/缓存）。  
**特征**：保持同一接口，持有被装饰对象指针。

~~~c++
struct Stream{ virtual std::string read()=0; virtual ~Stream()=default; };
struct FileStream: Stream{/*...*/};
struct EncryptStream: Stream{ Stream* inner; EncryptStream(Stream* s):inner(s){} 
  std::string read() override { auto d=inner->read(); /* encrypt */ return d; } };
~~~

**优点**：组合 > 继承。
**缺点**：对象层次过多导致调试困难。  
**对比**：与**Proxy**结构类似，但 Decorator 关注**增强功能**，Proxy 关注**控制访问**。

---

## 10) Facade（外观）

**意图**：为复杂子系统提供**统一的简单入口**。  
**何时用**：屏蔽复杂流程（启动、配置、依赖顺序）。  
**特征**：不限制子系统自由使用；只是**额外**的门面。

~~~c++
struct Facade{
  void start(){
    // Config->Init->Check->Run
  }
};
~~~

**优点**：降低学习/使用成本。
**缺点**：可能成为“上帝对象”。

---

## 11) Flyweight（享元）

**意图**：**共享**细粒度对象，减少内存。  
**何时用**：大量重复不可变对象（字符渲染、棋子/地图格）。  
**特征**：内部状态共享，外部状态由调用者传入。

~~~c++
struct Glyph{ char c; explicit Glyph(char c):c(c){} void draw(int x,int y){} };
struct GlyphFactory{
  std::unordered_map<char,std::unique_ptr<Glyph>> pool;
  Glyph* get(char c){ auto& p=pool[c]; if(!p) p=std::make_unique<Glyph>(c); return p.get(); }
};
~~~

**优点**：显著节省内存。**缺点**：逻辑复杂、调试难。

---

## 12) Proxy（代理）

**意图**：为其他对象提供**控制访问**的代理。  
**何时用**：远程代理、虚拟代理（懒加载）、保护代理、缓存代理。  
**特征**：与被代理对象同接口，内部持有真实对象或远程调用。

~~~c++
struct Image{ virtual void draw()=0; };
struct RealImage: Image{ RealImage(std::string path){/* load big file */} void draw() override {/*...*/}};
struct LazyImage: Image{ std::string path; std::unique_ptr<RealImage> real;
  LazyImage(std::string p):path(std::move(p)){} void draw() override {
    if(!real) real=std::make_unique<RealImage>(path); real->draw();
  }};
~~~

**优点**：性能/安全/分布式。**缺点**：额外复杂度。

---

# 行为型（11 个）

## 13) Chain of Responsibility（职责链）

**意图**：将多个处理者串成链，请求在链上传递，直到被处理。  
**何时用**：多个拦截/校验/处理步骤（日志、鉴权、风控）。  
**特征**：解耦发送者与接收者，组合顺序可变。

~~~c++
struct Handler{ Handler* next=nullptr; virtual bool handle(int v){ return next?next->handle(v):false; } };
struct Auth: Handler{ bool handle(int v) override { if(v==0) return false; return Handler::handle(v);} };
struct Limit: Handler{ bool handle(int v) override { if(v>100) return false; return Handler::handle(v);} };
~~~

**优点**：可扩展、可复用。**缺点**：定位处理者不直观。

---

## 14) Command（命令）

**意图**：把请求封装为对象，**支持撤销、排队、宏命令**。  
**何时用**：编辑器操作、事务队列、可撤销操作。  
**特征**：命令对象持有接收者和参数。

~~~c++
struct Light{ void on(){} void off(){} };
struct Command{ virtual void exec()=0; virtual void undo()=0; virtual ~Command()=default; };
struct LightOn: Command{ Light& l; LightOn(Light& l):l(l){} void exec() override { l.on(); } void undo() override { l.off(); } };
~~~

**优点**：解耦调用与实现；易做日志/撤销。**缺点**：命令类数目多。

---

## 15) Interpreter（解释器）

**意图**：为**特定领域语言**定义文法并解释执行。  
**何时用**：规则简单且稳定的小型 DSL（表达式、过滤规则）。  
**特征**：文法类层次 + 解释函数。

~~~c++
struct Expr{ virtual int eval()=0; };
struct Num: Expr{ int v; Num(int v):v(v){} int eval() override { return v; } };
struct Add: Expr{ Expr* a,*b; Add(Expr* a,Expr* b):a(a),b(b){} int eval() override { return a->eval()+b->eval(); } };
~~~

**优点**：直观表达业务规则。**缺点**：文法复杂度上升会爆炸；大多用**解析器/脚本引擎**替代。

---

## 16) Iterator（迭代器）

**意图**：提供**统一方式**顺序访问容器元素而不暴露内部结构。  
**何时用**：自定义聚合对象。  
**特征**：begin()/end() 或 next()/hasNext()。

~~~c++
// C++ STL 就是最佳示例；自定义容器暴露 iterator 即可
~~~

**优点**：统一遍历。**缺点**：对并发修改敏感。

---

## 17) Mediator（中介者）

**意图**：通过中介者**封装对象交互**，避免对象之间**网状引用**。  
**何时用**：控件/模块间交互复杂。  
**特征**：同事对象只与中介者通信。

~~~c++
struct Mediator{ virtual void notify(std::string from,std::string msg)=0; };
struct Chat: Mediator{ std::unordered_map<std::string,struct User*> users; /*...*/ void notify(std::string u,std::string m) override{/* broadcast */} };
struct User{ std::string name; Mediator& m; void send(std::string msg){ m.notify(name,msg); } };
~~~

**优点**：降低耦合，集中控制。**缺点**：中介者可能过于庞大。

---

## 18) Memento（备忘录）

**意图**：在**不破坏封装**的前提下保存和恢复对象状态。  
**何时用**：撤销/回滚。  
**特征**：Originator 产生 Memento，Caretaker 只保存。

~~~c++
struct Memento{ std::string state; };
struct Editor{
  std::string text;
  Memento save(){ return {text}; }
  void restore(const Memento& m){ text=m.state; }
};
~~~

**优点**：良好封装。**缺点**：快照成本、内存占用。

---

## 19) Observer（观察者）

**意图**：对象间**一对多**依赖，目标变化时自动通知所有观察者。  
**何时用**：事件系统、GUI、发布订阅。  
**特征**：Subject 维护观察者列表，push 或 pull。

~~~c++
struct Obs{ virtual void update(int)=0; };
struct Subject{ 
	int v=0; 
	std::vector<Obs*> list; 
	void attach(Obs* o)
	{
		list.push_back(o);
	} 
	void set(int nv){ 
		v=nv; 
		for(auto* o:list) o->update(v);
	} 
};
~~~

**优点**：解耦；支持多播。**缺点**：通知链调试不易；顺序/一致性问题。

---

## 20) State（状态）

**意图**：对象在**内部状态改变**时改变其行为（看似改变类）。  
**何时用**：有限状态机（订单流转、连接状态）。  
**特征**：将状态封装为类，环境持有当前状态。

~~~~c++
struct Context;
struct State{ virtual void handle(Context&)=0; virtual ~State()=default; };
struct Context{ std::unique_ptr<State> s; void request(){ s->handle(*this);} void set(std::unique_ptr<State> ns){ s=std::move(ns);} };
struct Open: State{ void handle(Context& c) override; };
struct Closed: State{ void handle(Context& c) override; };
// 在 handle 中切换 c.set(std::make_unique<Open>()) 等
~~~~

**优点**：代替分支爆炸；新增状态易扩展。**缺点**：类数量增加。

---

## 21) Strategy（策略）

**意图**：定义一族算法，**可互换**地使用。  
**何时用**：可插拔算法（排序、压缩、定价）。  
**特征**：上下文持有策略接口。

~~~c++
struct Sorter{ virtual void sort(std::vector<int>&)=0; };
struct Quick: Sorter{ void sort(std::vector<int>& a) override {/*...*/} };
struct Merge: Sorter{ void sort(std::vector<int>& a) override {/*...*/} };
struct Context{ std::unique_ptr<Sorter> s; void set(std::unique_ptr<Sorter> x){s=std::move(x);} void go(std::vector<int>& a){ s->sort(a);} };
~~~

**优点**：消除条件分支，开闭原则。**缺点**：调用者需理解差异。

---

## 22) Template Method（模板方法）

**意图**：在**父类**定义算法骨架，子类重写**可变步骤**。  
**何时用**：流程固定、步骤可定制（数据导入、训练流水线）。  
**特征**：hook 方法 + final 流程。

~~~c++
struct Game{
  void play(){ init(); loop(); teardown(); }
  virtual void init()=0; virtual void loop()=0; virtual void teardown()=0;
  virtual ~Game()=default;
};
~~~

**优点**：复用共性流程。**缺点**：继承耦合，灵活性不如**策略**。

---

## 23) Visitor（访问者）

**意图**：在不修改类的情况下，**为一组对象新增操作**。  
**何时用**：对象结构稳定、操作经常新增（AST 遍历、序列化）。  
**特征**：双分派：`element.accept(visitor)` → `visitor.visit(element)`。

~~~c
struct Circle; struct Rect;
struct Visitor{ virtual void visit(Circle&)=0; virtual void visit(Rect&)=0; };
struct Shape{ virtual void accept(Visitor&)=0; virtual ~Shape()=default; };
struct Circle: Shape{ void accept(Visitor& v) override { v.visit(*this);} };
struct Rect  : Shape{ void accept(Visitor& v) override { v.visit(*this);} };
~~~

**优点**：新增操作容易。**缺点**：新增**元素类型**困难。

---

## 速查：常见对比与选型建议

- **工厂方法 vs 抽象工厂**：单产品 vs 产品族；扩展维度不同。
    
- **Builder vs 抽象工厂**：Builder 强调“**一步步构造**”，抽象工厂强调“**同族一致**”。
    
- **Adapter vs Facade**：Adapter 做**接口转换**，Facade 做**简化入口**。
    
- **Decorator vs Proxy**：结构类似；Decorator 为**增强**，Proxy 为**控制/隔离**。
    
- **Bridge vs Strategy**：Bridge 是**结构解耦（抽象×实现）**，Strategy 是**算法可替换**。
    
- **Template Method vs Strategy**：模板用**继承**固化流程，策略用**组合**替换算法。
    
- **State vs Strategy**：State 通常由**内部状态**驱动切换；Strategy 由**外部选择**。
    

## 实战落地小建议

- 面向接口编程，优先**组合**而非继承。
    
- 先用简单结构（函数/组合），当“变化维度”稳定后再引入模式。
    
- 引入模式前，写下“**要隔离/复用/替换的变化点**”；用模式只为解决这个变化点。
    
- 对“有状态 + 多分支”的场景，优先考虑 **State/Strategy + 配置驱动**。
    
- 对“可撤销/重放”的场景，优先考虑 **Command + Memento**。
    
- 对“层级 + 统一操作”的场景，用 **Composite**；对“叠加能力”，用 **Decorator**。