## 一、无损连接性（Lossless-Join）

### 定义

把关系模式 **R** 分解成 **R1, R2, …, Rn**，如果自然连接 `R1 ⋈ R2 ⋈ … ⋈ Rn` 可以**精确还原**原始关系 R（不丢失、不产生额外假元组），就叫做**无损连接分解**。

### 判断方法（常用）

1. **两表分解情况（R → R1, R2）**：
    
    - 若 `R1 ∩ R2` 是 **R1 或 R2 的候选码**，则分解是 **无损的**。
        
    - 记忆口诀：**交集是码 → 无损**。
        
2. **更一般情况**：
    
    - 使用 **Chase 算法**（教科书方法）：逐步用函数依赖替换和扩展，检查是否能推导出原关系。
        
    - 实际应用里，常只考“两表分解”的充分必要条件。
        

### 举例

关系 `R(学号, 姓名, 系号, 系名)`  
函数依赖：`学号 → 姓名, 系号`，`系号 → 系名`

分解：

- R1(学号, 姓名, 系号)
    
- R2(系号, 系名)
    

检查交集：`R1 ∩ R2 = {系号}`

- 在 R2 中，`系号 → 系名`，说明 `系号` 是 **R2 的主码**  
    ➡️ 符合“交集是码”，所以是 **无损连接分解**。
    

---

## 二、保持函数依赖（Dependency Preservation）

### 定义

分解后，**原关系 R 的所有函数依赖 F**，能从**各子模式上的函数依赖的并集**推出（F⁺ = (F1 ∪ F2 ∪ … ∪ Fn)⁺），就叫**保持函数依赖**。

换句话说：在分解后的子表上就能检查约束，而不需要再做跨表检查。

### 判断方法

- 设原函数依赖集是 **F**，分解得到 R1, R2。
    
- 取 `F1 = 投影到R1上的依赖`，`F2 = 投影到R2上的依赖`。
    
- 如果 `F⁺ = (F1 ∪ F2)⁺`，则保持函数依赖。
    
- 实际考试/作业里，经常要求你检验某些依赖能否只在子表里验证。
    

### 举例

还是 `R(学号, 姓名, 系号, 系名)`  
依赖：`学号 → 姓名, 系号`，`系号 → 系名`

分解：

- R1(学号, 姓名, 系号) → 投影后有 `学号 → 姓名, 系号`
    
- R2(系号, 系名) → 投影后有 `系号 → 系名`
    

F1 ∪ F2 刚好就是原来的依赖集合 F，  
➡️ 所以该分解 **保持函数依赖**。